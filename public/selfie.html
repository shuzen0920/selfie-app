<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>自拍相機 (Node.js Server)</title>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    background-color: #f0f2f5;
    color: #333;
    margin: 0;
    padding: 20px;
    -webkit-tap-highlight-color: transparent;
  }
  h1 {
    color: #333;
    text-align: center;
    font-size: 1.2rem;
  }
  .container {
    position: relative;
    width: 100%;
    max-width: 480px;
    aspect-ratio: 2 / 3;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    background-color: #000;
  }
  #camera-preview {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #frame {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
  }
  #dynamic-logo {
    position: absolute;
    display: none;
    z-index: 2;
    object-fit: contain;
    pointer-events: none;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .button-group {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  .button-group button {
    padding: 12px 24px;
    font-size: 18px;
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
  }
  .button-group button:active {
      transform: scale(0.95);
  }
  #switch-camera-button { background-color: #6c757d; }
  #switch-camera-button:hover { background-color: #5a6268; }
  #capture-button { background-color: #dc3545; }
  #capture-button:hover { background-color: #c82333; }
  #save-button { background-color: #28a745; }
  #save-button:hover { background-color: #218838; }
  #retake-button { background-color: #007bff; }
  #retake-button:hover { background-color: #0056b3; }
  #preview-container {
    display: none;
    flex-direction: column;
    align-items: center;
  }
  #preview-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
</style>
</head>
<body>
  <h1>拍照＋上傳＋填問卷，才能換點數喔！</h1>
  <div id="camera-container" style="display: flex; flex-direction: column; align-items: center;">
    <div class="container">
      <video id="camera-preview" autoplay playsinline muted></video>
      <img id="frame" src="/frame.png" alt="邊框" crossorigin="anonymous">
      <img id="dynamic-logo" src="/logo.png" alt="Logo" crossorigin="anonymous">
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
    <div class="button-group">
      <div class="controls">
        <input type="checkbox" id="add-logo-checkbox">
        <label for="add-logo-checkbox">加入 Logo</label>
        <input type="checkbox" id="beautify-checkbox">
        <label for="beautify-checkbox">美肌模式</label>
      </div>
      <button id="switch-camera-button">切換鏡頭</button>
      <button id="capture-button">拍照</button>
    </div>
  </div>

  <div id="preview-container">
    <div class="container">
      <img id="preview-image" src="" alt="拍照預覽">
    </div>
    <div class="button-group">
      <button id="save-button">儲存</button>
      <button id="retake-button">重拍</button>
    </div>
  </div>

  <script>
    const cameraPreview = document.getElementById('camera-preview');
    const frameImage = document.getElementById('frame');
    const captureButton = document.getElementById('capture-button');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraContainer = document.getElementById('camera-container');
    const previewContainer = document.getElementById('preview-container');
    const previewImage = document.getElementById('preview-image');
    const saveButton = document.getElementById('save-button');
    const retakeButton = document.getElementById('retake-button');
    const addLogoCheckbox = document.getElementById('add-logo-checkbox');
    const beautifyCheckbox = document.getElementById('beautify-checkbox');
    const switchCameraButton = document.getElementById('switch-camera-button');
    const dynamicLogo = document.getElementById('dynamic-logo');

    const logoImage = new Image();
    logoImage.src = '/logo.png';
    logoImage.crossOrigin = 'anonymous';

    let currentStream;
    let currentFacingMode = 'user';
    let faceModelsLoaded = false;
    let faceDetectionInterval;
    let lastLogoPosition = null;
    // ===== 新增：儲存預覽時的影像尺寸 =====
    let previewVideoDimensions = { width: 0, height: 0 };

    async function loadFaceApiModels() {
      const MODEL_URL = '/weights';
      try {
        await faceapi.nets.tinyFaceDetector.load(MODEL_URL);
        faceModelsLoaded = true;
        console.log('Face API models loaded.');
      } catch (e) {
        console.error("載入人臉偵測模型失敗。", e);
        alert("載入人臉偵測模型失敗，Logo 追蹤功能將無法使用。");
      }
    }

    async function startCamera(facingMode) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      try {
        const constraints = {
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            facingMode: facingMode
          }
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraPreview.srcObject = currentStream;
        await new Promise(resolve => cameraPreview.onloadedmetadata = resolve);
        
        cameraPreview.style.transform = (facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

        if (!faceModelsLoaded) await loadFaceApiModels();
        if (faceModelsLoaded) startFaceDetection();

      } catch (error) {
        console.error('無法取得相機存取權:', error);
        alert(`無法啟動相機 (${facingMode})。\n請確認您已授權，並使用 HTTPS 安全連線。`);
      }
    }

    function startFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      
      faceDetectionInterval = setInterval(async () => {
        if (!faceModelsLoaded || !cameraPreview.srcObject || !addLogoCheckbox.checked) {
          dynamicLogo.style.display = 'none';
          lastLogoPosition = null;
          return;
        }

        const detections = await faceapi.detectAllFaces(cameraPreview, new faceapi.TinyFaceDetectorOptions());
        
        if (detections.length > 0) {
          const face = detections[0].box;
          
          const videoWidth = cameraPreview.videoWidth;
          const videoHeight = cameraPreview.videoHeight;
          const viewWidth = cameraPreview.offsetWidth;
          const viewHeight = cameraPreview.offsetHeight;

          // ===== 關鍵修改 1：儲存當前用於偵測的影像尺寸 =====
          previewVideoDimensions.width = videoWidth;
          previewVideoDimensions.height = videoHeight;

          const scale = Math.max(viewWidth / videoWidth, viewHeight / videoHeight);
          const offsetX = (viewWidth - videoWidth * scale) / 2;
          const offsetY = (viewHeight - videoHeight * scale) / 2;

          const viewFaceX = face.x * scale + offsetX;
          const viewFaceY = face.y * scale + offsetY;
          const viewFaceWidth = face.width * scale;

          const logoWidth = viewFaceWidth * 0.5;
          const logoHeight = logoImage.naturalHeight * (logoWidth / logoImage.naturalWidth);
          let logoX = viewFaceX + (viewFaceWidth / 2) - (logoWidth / 2) - 80;
          let logoY = viewFaceY - logoHeight - 30;

          logoX = Math.max(0, Math.min(viewWidth - logoWidth, logoX));
          logoY = Math.max(0, Math.min(viewHeight - logoHeight, logoY));

          dynamicLogo.style.left = `${logoX}px`;
          dynamicLogo.style.top = `${logoY}px`;
          dynamicLogo.style.width = `${logoWidth}px`;
          dynamicLogo.style.height = `${logoHeight}px`;
          dynamicLogo.style.display = 'block';

          // lastLogoPosition 現在儲存的是相對於「預覽時」影像的座標
          lastLogoPosition = {
            x: (logoX - offsetX) / scale,
            y: (logoY - offsetY) / scale,
            width: logoWidth / scale,
            height: logoHeight / scale
          };
        } else {
          dynamicLogo.style.display = 'none';
          lastLogoPosition = null;
        }
      }, 200);
    }

    function stopFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      dynamicLogo.style.display = 'none';
    }

    function takePicture() {
      if (!cameraPreview.srcObject || !frameImage.complete) {
        alert('相機或邊框尚未準備好，請稍候再試。');
        return;
      }
      
      stopFaceDetection();

      const videoWidth = cameraPreview.videoWidth;
      const videoHeight = cameraPreview.videoHeight;
      const containerWidth = cameraPreview.offsetWidth;
      const containerHeight = cameraPreview.offsetHeight;

      const { sx, sy, sWidth, sHeight } = calculateCoverCrop(videoWidth, videoHeight, containerWidth, containerHeight);

      const outputWidth = 1080;
      const outputHeight = outputWidth * (containerHeight / containerWidth);
      canvas.width = outputWidth;
      canvas.height = outputHeight;

      drawFlippedAndCroppedVideo(ctx, cameraPreview, sx, sy, sWidth, sHeight);

      if (beautifyCheckbox.checked) {
        applyBeautifyFilter(ctx);
      }
      
      ctx.drawImage(frameImage, 0, 0, canvas.width, canvas.height);

      if (addLogoCheckbox.checked && logoImage.complete && lastLogoPosition) {
        // ===== 關鍵修改 2：將預覽時的尺寸傳入，進行校準 =====
        drawLogoOnCanvas(ctx, logoImage, lastLogoPosition, { sx, sy, sWidth }, previewVideoDimensions);
      }

      previewImage.src = canvas.toDataURL('image/jpeg', 0.9);
      cameraContainer.style.display = 'none';
      previewContainer.style.display = 'flex';
    }

    function calculateCoverCrop(srcWidth, srcHeight, containerWidth, containerHeight) {
      const srcAspect = srcWidth / srcHeight;
      const containerAspect = containerWidth / containerHeight;
      let sx = 0, sy = 0, sWidth = srcWidth, sHeight = srcHeight;

      if (containerAspect < srcAspect) {
        sWidth = srcHeight * containerAspect;
        sx = (srcWidth - sWidth) / 2;
      } else if (containerAspect > srcAspect) {
        sHeight = srcWidth / containerAspect;
        sy = (srcHeight - sHeight) / 2;
      }
      return { sx, sy, sWidth, sHeight };
    }

    function drawFlippedAndCroppedVideo(context, video, sx, sy, sWidth, sHeight) {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      
      if (currentFacingMode === 'user') {
        context.save();
        context.scale(-1, 1);
        context.translate(-context.canvas.width, 0);
      }

      context.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, context.canvas.width, context.canvas.height);

      if (currentFacingMode === 'user') {
        context.restore();
      }
    }

    // ===== 核心修改：drawLogoOnCanvas 現在接收預覽時的尺寸進行校準 =====
    function drawLogoOnCanvas(context, logo, logoPos, cropInfo, previewDimensions) {
      // 如果沒有預覽尺寸資訊，則無法校準，直接返回
      if (!previewDimensions || previewDimensions.width === 0) {
        console.warn("無法獲取預覽時的影像尺寸，Logo 位置可能不準確。");
        return;
      }

      // 1. 獲取拍照時的影像尺寸（裁切後的寬度）和最終畫布尺寸
      const captureCropWidth = cropInfo.sWidth;
      const finalCanvasWidth = context.canvas.width;

      // 2. 計算從「預覽影像」到「拍照影像」的尺寸校準比例
      // 這是解決 Zoom Out 問題的關鍵！
      const calibrationScale = captureCropWidth / (previewDimensions.width * (captureCropWidth / cameraPreview.videoWidth));

      // 3. 將儲存的 logoPos（基於預覽影像）進行校準，得到它在「拍照影像」中的對應位置
      const calibratedLogoX = logoPos.x * calibrationScale;
      const calibratedLogoY = logoPos.y * calibrationScale;
      const calibratedLogoWidth = logoPos.width * calibrationScale;
      const calibratedLogoHeight = logoPos.height * calibrationScale;

      // 4. 計算從「拍照影像的裁切區域」到「最終畫布」的繪製縮放比例
      const drawScale = finalCanvasWidth / captureCropWidth;

      // 5. 將校準後的 Logo 座標，轉換到最終畫布上
      const logoDrawX = (calibratedLogoX - cropInfo.sx) * drawScale;
      const logoDrawY = (calibratedLogoY - cropInfo.sy) * drawScale;
      const logoDrawWidth = calibratedLogoWidth * drawScale;
      const logoDrawHeight = calibratedLogoHeight * drawScale;
      
      // 6. 繪製 Logo（並處理前鏡頭翻轉）
      if (currentFacingMode === 'user') {
        const finalFlippedLogoX = finalCanvasWidth - logoDrawX - logoDrawWidth;
        context.drawImage(logo, finalFlippedLogoX, logoDrawY, logoDrawWidth, logoDrawHeight);
      } else {
        context.drawImage(logo, logoDrawX, logoDrawY, logoDrawWidth, logoDrawHeight);
      }
    }

    function applyBeautifyFilter(context) {
        const { width, height } = context.canvas;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        tempCtx.drawImage(context.canvas, 0, 0);

        context.filter = 'brightness(1.05) contrast(1.05) saturate(1.1)';
        context.drawImage(tempCanvas, 0, 0);
        context.filter = 'none';
    }

    function savePicture() {
      const imageDataURL = previewImage.src;
      const downloadLink = document.createElement('a');
      downloadLink.href = imageDataURL;
      downloadLink.download = `selfie-${Date.now()}.jpg`;
      downloadLink.click();
    }

    function retakePicture() {
      previewContainer.style.display = 'none';
      cameraContainer.style.display = 'flex';
      if (faceModelsLoaded) {
        startFaceDetection();
      }
    }

    function switchCamera() {
      stopFaceDetection();
      currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
      startCamera(currentFacingMode);
    }

    captureButton.addEventListener('click', takePicture);
    saveButton.addEventListener('click', savePicture);
    retakeButton.addEventListener('click', retakePicture);
    switchCameraButton.addEventListener('click', switchCamera);
    addLogoCheckbox.addEventListener('change', () => {
      if (!addLogoCheckbox.checked) {
        dynamicLogo.style.display = 'none';
        lastLogoPosition = null;
      }
    });

    startCamera(currentFacingMode);
  </script>
</body>
</html>

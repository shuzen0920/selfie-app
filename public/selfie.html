<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>自拍相機 (Node.js Server)</title>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    background-color: #f0f2f5;
    color: #333;
    margin: 0;
    padding: 20px;
    -webkit-tap-highlight-color: transparent; /* 移除行動裝置點擊高亮 */
  }
  h1 {
    color: #333;
    text-align: center;
    font-size: 1.2rem;
  }
  .container {
    position: relative;
    width: 100%;
    max-width: 480px;
    aspect-ratio: 2 / 3;
    border-radius: 15px; /* 圓角更明顯 */
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    background-color: #000; /* 預設背景 */
  }
  #camera-preview {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 關鍵：讓預覽畫面填滿容器且不變形 */
  }
  #frame {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
  }
  #dynamic-logo {
    position: absolute;
    display: none;
    z-index: 2;
    object-fit: contain;
    pointer-events: none;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .button-group {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  .button-group button {
    padding: 12px 24px;
    font-size: 18px;
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
  }
  .button-group button:active {
      transform: scale(0.95); /* 增加點擊回饋 */
  }
  #switch-camera-button { background-color: #6c757d; }
  #switch-camera-button:hover { background-color: #5a6268; }
  #capture-button { background-color: #dc3545; }
  #capture-button:hover { background-color: #c82333; }
  #save-button { background-color: #28a745; }
  #save-button:hover { background-color: #218838; }
  #retake-button { background-color: #007bff; }
  #retake-button:hover { background-color: #0056b3; }
  #preview-container {
    display: none; /* 初始隱藏 */
    flex-direction: column;
    align-items: center;
  }
  #preview-image {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 讓預覽圖也保持比例 */
  }
</style>
</head>
<body>
  <h1>拍照＋上傳＋填問卷，才能換點數喔！</h1>
  <!-- 即時相機畫面 -->
  <div id="camera-container" style="display: flex; flex-direction: column; align-items: center;">
    <div class="container">
      <video id="camera-preview" autoplay playsinline muted></video> <!-- 加上 muted 避免潛在的自動播放問題 -->
      <img id="frame" src="/frame.png" alt="邊框" crossorigin="anonymous">
      <img id="dynamic-logo" src="/logo.png" alt="Logo" crossorigin="anonymous">
      <!-- Canvas 不再需要固定尺寸，由 JS 動態設定 -->
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
    <div class="button-group">
      <div class="controls">
        <input type="checkbox" id="add-logo-checkbox">
        <label for="add-logo-checkbox">加入 Logo</label>
        <input type="checkbox" id="beautify-checkbox">
        <label for="beautify-checkbox">美肌模式</label>
      </div>
      <button id="switch-camera-button">切換鏡頭</button>
      <button id="capture-button">拍照</button>
    </div>
  </div>

  <!-- 拍照後的預覽畫面 -->
  <div id="preview-container">
    <div class="container">
      <img id="preview-image" src="" alt="拍照預覽">
    </div>
    <div class="button-group">
      <button id="save-button">儲存</button>
      <button id="retake-button">重拍</button>
    </div>
  </div>

  <script>
    // ===== 1. 元素獲取 (保持不變) =====
    const cameraPreview = document.getElementById('camera-preview');
    const frameImage = document.getElementById('frame');
    const captureButton = document.getElementById('capture-button');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraContainer = document.getElementById('camera-container');
    const previewContainer = document.getElementById('preview-container');
    const previewImage = document.getElementById('preview-image');
    const saveButton = document.getElementById('save-button');
    const retakeButton = document.getElementById('retake-button');
    const addLogoCheckbox = document.getElementById('add-logo-checkbox');
    const beautifyCheckbox = document.getElementById('beautify-checkbox');
    const switchCameraButton = document.getElementById('switch-camera-button');
    const dynamicLogo = document.getElementById('dynamic-logo');

    // ===== 2. 狀態變數與資源預載入 (保持不變) =====
    const logoImage = new Image();
    logoImage.src = '/logo.png';
    logoImage.crossOrigin = 'anonymous';

    let currentStream;
    let currentFacingMode = 'user';
    let faceModelsLoaded = false;
    let faceDetectionInterval;
    let lastLogoPosition = null;

    // ===== 3. 核心功能函式 (重構與優化) =====

    async function loadFaceApiModels() {
      const MODEL_URL = '/weights';
      try {
        await faceapi.nets.tinyFaceDetector.load(MODEL_URL);
        faceModelsLoaded = true;
        console.log('Face API models loaded.');
      } catch (e) {
        console.error("載入人臉偵測模型失敗。", e);
        alert("載入人臉偵測模型失敗，Logo 追蹤功能將無法使用。");
      }
    }

    async function startCamera(facingMode) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      try {
        // 請求高解析度影像，讓瀏覽器自己選擇最佳的
        const constraints = {
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            facingMode: facingMode
          }
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraPreview.srcObject = currentStream;
        await new Promise(resolve => cameraPreview.onloadedmetadata = resolve);
        
        cameraPreview.style.transform = (facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

        if (!faceModelsLoaded) await loadFaceApiModels();
        if (faceModelsLoaded) startFaceDetection();

      } catch (error) {
        console.error('無法取得相機存取權:', error);
        alert(`無法啟動相機 (${facingMode})。\n請確認您已授權，並使用 HTTPS 安全連線。`);
      }
    }

    function startFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      
      faceDetectionInterval = setInterval(async () => {
        if (!faceModelsLoaded || !cameraPreview.srcObject || !addLogoCheckbox.checked) {
          dynamicLogo.style.display = 'none';
          lastLogoPosition = null;
          return;
        }

        const detections = await faceapi.detectAllFaces(cameraPreview, new faceapi.TinyFaceDetectorOptions());
        
        if (detections.length > 0) {
          const face = detections[0].box;
          
          // ===== 關鍵修改：所有計算都基於 Video 的原生尺寸 =====
          const videoWidth = cameraPreview.videoWidth;
          const videoHeight = cameraPreview.videoHeight;
          const viewWidth = cameraPreview.offsetWidth;
          const viewHeight = cameraPreview.offsetHeight;

          // 計算影像串流與預覽畫面的縮放比例
          const scaleX = viewWidth / videoWidth;
          const scaleY = viewHeight / videoHeight;
          // 由於 object-fit: cover，我們取較大的縮放比例
          const scale = Math.max(scaleX, scaleY);

          // 計算畫面置中後的偏移量
          const offsetX = (viewWidth - videoWidth * scale) / 2;
          const offsetY = (viewHeight - videoHeight * scale) / 2;

          // 將偵測到的人臉座標轉換為預覽畫面上的座標
          const viewFaceX = face.x * scale + offsetX;
          const viewFaceY = face.y * scale + offsetY;
          const viewFaceWidth = face.width * scale;

          // 計算 Logo 在預覽畫面上的位置和大小
          const logoWidth = viewFaceWidth * 0.5;
          const logoHeight = logoImage.naturalHeight * (logoWidth / logoImage.naturalWidth);
          let logoX = viewFaceX + (viewFaceWidth / 2) - (logoWidth / 2) - 80;
          let logoY = viewFaceY - logoHeight - 30;

          // 確保 Logo 在預覽畫面內
          logoX = Math.max(0, Math.min(viewWidth - logoWidth, logoX));
          logoY = Math.max(0, Math.min(viewHeight - logoHeight, logoY));

          dynamicLogo.style.left = `${logoX}px`;
          dynamicLogo.style.top = `${logoY}px`;
          dynamicLogo.style.width = `${logoWidth}px`;
          dynamicLogo.style.height = `${logoHeight}px`;
          dynamicLogo.style.display = 'block';

          // 儲存 Logo 相對於 *原始影像* 的位置，供 Canvas 使用
          lastLogoPosition = {
            x: (logoX - offsetX) / scale,
            y: (logoY - offsetY) / scale,
            width: logoWidth / scale,
            height: logoHeight / scale
          };
        } else {
          dynamicLogo.style.display = 'none';
          lastLogoPosition = null;
        }
      }, 200); // 降低偵測頻率以節省效能
    }

    function stopFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      dynamicLogo.style.display = 'none';
    }

    // ===== 核心修改：重構 takePicture 函式 =====
    function takePicture() {
      if (!cameraPreview.srcObject || !frameImage.complete) {
        alert('相機或邊框尚未準備好，請稍候再試。');
        return;
      }
      
      stopFaceDetection();

      // 1. 獲取影像和容器的尺寸與比例
      const videoWidth = cameraPreview.videoWidth;
      const videoHeight = cameraPreview.videoHeight;
      const containerWidth = cameraPreview.offsetWidth;
      const containerHeight = cameraPreview.offsetHeight;
      const containerAspect = containerWidth / containerHeight;
      const videoAspect = videoWidth / videoHeight;

      // 2. 計算裁切區域 (Source) 和繪製尺寸 (Destination)
      let sx = 0, sy = 0, sWidth = videoWidth, sHeight = videoHeight;

      // 這是實現 object-fit: cover 的核心邏輯
      // 如果容器比影像更「瘦高」，則左右裁切影像
      if (containerAspect < videoAspect) {
        sWidth = videoHeight * containerAspect;
        sx = (videoWidth - sWidth) / 2;
      } 
      // 如果容器比影像更「矮胖」，則上下裁切影像
      else if (containerAspect > videoAspect) {
        sHeight = videoWidth / containerAspect;
        sy = (videoHeight - sHeight) / 2;
      }

      // 3. 設定 Canvas 尺寸以匹配最終輸出比例，並獲取高畫質
      // 我們可以設定一個理想的輸出寬度，例如 1080px
      const outputWidth = 1080;
      const outputHeight = outputWidth / containerAspect;
      canvas.width = outputWidth;
      canvas.height = outputHeight;

      // 4. 繪製影像
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 如果是前鏡頭，先設定水平翻轉
      if (currentFacingMode === 'user') {
        ctx.save();
        ctx.scale(-1, 1);
        ctx.translate(-canvas.width, 0);
      }

      // 將裁切後的影像部分繪製到整個 Canvas 上
      ctx.drawImage(cameraPreview, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);

      if (currentFacingMode === 'user') {
        ctx.restore(); // 恢復翻轉狀態，後續繪製不受影響
      }

      // 5. 繪製附加元素（美肌、邊框、Logo）
      if (beautifyCheckbox.checked) {
        applyBeautifyFilter(ctx, canvas.width, canvas.height);
      }
      
      // 繪製邊框
      ctx.drawImage(frameImage, 0, 0, canvas.width, canvas.height);

      // 繪製 Logo
      if (addLogoCheckbox.checked && logoImage.complete && lastLogoPosition) {
        // 計算 Logo 在新 Canvas 上的繪製位置
        const drawScale = canvas.width / sWidth;
        const logoDrawX = (lastLogoPosition.x - sx) * drawScale;
        const logoDrawY = (lastLogoPosition.y - sy) * drawScale;
        const logoDrawWidth = lastLogoPosition.width * drawScale;
        const logoDrawHeight = lastLogoPosition.height * drawScale;
        
        // 如果是前鏡頭，Logo 的 X 座標也需要翻轉
        if (currentFacingMode === 'user') {
            const finalLogoX = canvas.width - logoDrawX - logoDrawWidth;
            ctx.drawImage(logoImage, finalLogoX, logoDrawY, logoDrawWidth, logoDrawHeight);
        } else {
            ctx.drawImage(logoImage, logoDrawX, logoDrawY, logoDrawWidth, logoDrawHeight);
        }
      }

      // 6. 顯示結果
      previewImage.src = canvas.toDataURL('image/jpeg', 0.9); // 使用 JPEG 格式以節省空間
      cameraContainer.style.display = 'none';
      previewContainer.style.display = 'flex';
    }

    // 簡單的美肌濾鏡 (保持不變)
    function applyBeautifyFilter(ctx, width, height) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        tempCtx.drawImage(canvas, 0, 0);

        ctx.filter = 'brightness(1.05) contrast(1.05) saturate(1.1)';
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.filter = 'none';
    }

    // ===== 4. 事件處理函式 (部分修改) =====

    function savePicture() {
      // 這裡可以替換成上傳到伺服器的邏輯
      const imageDataURL = previewImage.src;
      console.log('準備上傳圖片，Base64 資料長度:', imageDataURL.length);
      alert('圖片已儲存（請查看主控台）。實際應用中，這裡會是上傳邏輯。');
      
      // 模擬下載
      const downloadLink = document.createElement('a');
      downloadLink.href = imageDataURL;
      downloadLink.download = `selfie-${Date.now()}.jpg`;
      downloadLink.click();
    }

    function retakePicture() {
      previewContainer.style.display = 'none';
      cameraContainer.style.display = 'flex';
      if (faceModelsLoaded) {
        startFaceDetection();
      }
    }

    function switchCamera() {
      stopFaceDetection();
      currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
      startCamera(currentFacingMode);
    }

    // ===== 5. 事件綁定與初始化 (保持不變) =====
    captureButton.addEventListener('click', takePicture);
    saveButton.addEventListener('click', savePicture);
    retakeButton.addEventListener('click', retakePicture);
    switchCameraButton.addEventListener('click', switchCamera);
    addLogoCheckbox.addEventListener('change', () => {
      if (!addLogoCheckbox.checked) {
        dynamicLogo.style.display = 'none';
        lastLogoPosition = null;
      }
    });

    // 初始啟動相機
    startCamera(currentFacingMode);
  </script>
</body>
</html>

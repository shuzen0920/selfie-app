<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>自拍相機 (Node.js Server)</title>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    background-color: #f0f2f5;
    color: #333;
    margin: 0;
    padding: 20px;
    -webkit-tap-highlight-color: transparent;
  }
  h1 {
    color: #333;
    text-align: center;
    font-size: 1.2rem;
  }
  .container {
    position: relative;
    width: 100%;
    max-width: 480px;
    aspect-ratio: 2 / 3;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    background-color: #000;
  }
  #camera-preview {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #frame {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
  }
  #dynamic-logo {
    position: absolute;
    display: none;
    z-index: 2;
    object-fit: contain;
    pointer-events: none;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .button-group {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }
  .button-group button {
    padding: 12px 24px;
    font-size: 18px;
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
  }
  .button-group button:active {
      transform: scale(0.95);
  }
  #switch-camera-button { background-color: #6c757d; }
  #switch-camera-button:hover { background-color: #5a6268; }
  #capture-button { background-color: #dc3545; }
  #capture-button:hover { background-color: #c82333; }
  #save-button { background-color: #28a745; }
  #save-button:hover { background-color: #218838; }
  #retake-button { background-color: #007bff; }
  #retake-button:hover { background-color: #0056b3; }
  #preview-container {
    display: none;
    flex-direction: column;
    align-items: center;
  }
  #preview-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
</style>
</head>
<body>
  <h1>拍照＋上傳＋填問卷，才能換點數喔！</h1>
  <div id="camera-container" style="display: flex; flex-direction: column; align-items: center;">
    <div class="container">
      <video id="camera-preview" autoplay playsinline muted></video>
      <img id="frame" src="/frame.png" alt="邊框" crossorigin="anonymous">
      <img id="dynamic-logo" src="/logo.png" alt="Logo" crossorigin="anonymous">
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
    <div class="button-group">
      <div class="controls">
        <input type="checkbox" id="add-logo-checkbox">
        <label for="add-logo-checkbox">加入 Logo</label>
        <input type="checkbox" id="beautify-checkbox">
        <label for="beautify-checkbox">美肌模式</label>
      </div>
      <button id="switch-camera-button">切換鏡頭</button>
      <button id="capture-button">拍照</button>
    </div>
  </div>

  <div id="preview-container">
    <div class="container">
      <img id="preview-image" src="" alt="拍照預覽">
    </div>
    <div class="button-group">
      <button id="save-button">儲存</button>
      <button id="retake-button">重拍</button>
    </div>
  </div>

  <script>
    const cameraPreview = document.getElementById('camera-preview');
    const frameImage = document.getElementById('frame');
    const captureButton = document.getElementById('capture-button');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraContainer = document.getElementById('camera-container');
    const previewContainer = document.getElementById('preview-container');
    const previewImage = document.getElementById('preview-image');
    const saveButton = document.getElementById('save-button');
    const retakeButton = document.getElementById('retake-button');
    const addLogoCheckbox = document.getElementById('add-logo-checkbox');
    const beautifyCheckbox = document.getElementById('beautify-checkbox');
    const switchCameraButton = document.getElementById('switch-camera-button');
    const dynamicLogo = document.getElementById('dynamic-logo');

    const logoImage = new Image();
    logoImage.src = '/logo.png';
    logoImage.crossOrigin = 'anonymous';

    let currentStream;
    let currentFacingMode = 'user';
    let faceModelsLoaded = false;
    let faceDetectionInterval;
    let imageCapture = null;

    async function loadFaceApiModels() {
      const MODEL_URL = '/weights';
      try {
        await faceapi.nets.tinyFaceDetector.load(MODEL_URL);
        faceModelsLoaded = true;
        console.log('Face API models loaded.');
      } catch (e) {
        console.error("載入人臉偵測模型失敗。", e);
        alert("載入人臉偵測模型失敗，Logo 追蹤功能將無法使用。");
      }
    }

    async function startCamera(facingMode) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      imageCapture = null;

      try {
        const constraints = {
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            facingMode: facingMode
          }
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraPreview.srcObject = currentStream;
        await new Promise(resolve => cameraPreview.onloadedmetadata = resolve);
        
        if ('ImageCapture' in window) {
          const track = currentStream.getVideoTracks()[0];
          imageCapture = new ImageCapture(track);
          console.log('ImageCapture is supported and initialized.');
        } else {
          console.warn('ImageCapture is not supported. Falling back to canvas.drawImage().');
        }

        cameraPreview.style.transform = (facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

        if (!faceModelsLoaded) await loadFaceApiModels();
        if (faceModelsLoaded) startPreviewFaceDetection();

      } catch (error) {
        console.error('無法取得相機存取權:', error);
        alert(`無法啟動相機 (${facingMode})。\n請確認您已授權，並使用 HTTPS 安全連線。`);
      }
    }

    // 重新命名以區分：這只用於「預覽」
    function startPreviewFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      
      faceDetectionInterval = setInterval(async () => {
        if (!faceModelsLoaded || !cameraPreview.srcObject || !addLogoCheckbox.checked) {
          dynamicLogo.style.display = 'none';
          return;
        }

        const detections = await faceapi.detectAllFaces(cameraPreview, new faceapi.TinyFaceDetectorOptions());
        
        if (detections.length > 0) {
          const face = detections[0].box;
          const videoWidth = cameraPreview.videoWidth;
          const videoHeight = cameraPreview.videoHeight;
          const viewWidth = cameraPreview.offsetWidth;
          const viewHeight = cameraPreview.offsetHeight;
          const scale = Math.max(viewWidth / videoWidth, viewHeight / videoHeight);
          const offsetX = (viewWidth - videoWidth * scale) / 2;
          const offsetY = (viewHeight - videoHeight * scale) / 2;
          const viewFaceX = face.x * scale + offsetX;
          const viewFaceY = face.y * scale + offsetY;
          const viewFaceWidth = face.width * scale;
          const logoWidth = viewFaceWidth * 0.5;
          const logoHeight = logoImage.naturalHeight * (logoWidth / logoImage.naturalWidth);
          let logoX = viewFaceX + (viewFaceWidth / 2) - (logoWidth / 2) - 80;
          let logoY = viewFaceY - logoHeight - 30;
          logoX = Math.max(0, Math.min(viewWidth - logoWidth, logoX));
          logoY = Math.max(0, Math.min(viewHeight - logoHeight, logoY));

          dynamicLogo.style.left = `${logoX}px`;
          dynamicLogo.style.top = `${logoY}px`;
          dynamicLogo.style.width = `${logoWidth}px`;
          dynamicLogo.style.height = `${logoHeight}px`;
          dynamicLogo.style.display = 'block';
        } else {
          dynamicLogo.style.display = 'none';
        }
      }, 200);
    }

    function stopPreviewFaceDetection() {
      if (faceDetectionInterval) clearInterval(faceDetectionInterval);
      dynamicLogo.style.display = 'none';
    }

    async function takePicture() {
      if (!currentStream) {
        alert('相機尚未準備好。');
        return;
      }
      stopPreviewFaceDetection();
      captureButton.disabled = true;

      try {
        let imageBlob;
        if (imageCapture) {
          imageBlob = await imageCapture.takePhoto();
        } else {
          canvas.width = cameraPreview.videoWidth;
          canvas.height = cameraPreview.videoHeight;
          ctx.drawImage(cameraPreview, 0, 0);
          imageBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
        }
        await composeFinalImage(imageBlob);
      } catch (error) {
        console.error('拍照失敗:', error);
        alert('拍照失敗，請再試一次。');
      } finally {
        captureButton.disabled = false;
      }
    }

    // ===== 核心修改：在合成階段重新進行人臉偵測 =====
    async function composeFinalImage(imageBlob) {
      const capturedBmp = await createImageBitmap(imageBlob);
      const containerWidth = cameraPreview.offsetWidth;
      const containerHeight = cameraPreview.offsetHeight;
      const { sx, sy, sWidth, sHeight } = calculateCoverCrop(capturedBmp.width, capturedBmp.height, containerWidth, containerHeight);

      const outputWidth = 1080;
      const outputHeight = outputWidth * (containerHeight / containerWidth);
      canvas.width = outputWidth;
      canvas.height = outputHeight;

      drawFlippedAndCroppedImage(ctx, capturedBmp, sx, sy, sWidth, sHeight);

      if (beautifyCheckbox.checked) {
        applyBeautifyFilter(ctx);
      }
      ctx.drawImage(frameImage, 0, 0, canvas.width, canvas.height);

      // --- 關鍵步驟：在最終畫布上繪製 Logo 前，重新偵測 ---
      if (addLogoCheckbox.checked && logoImage.complete && faceModelsLoaded) {
        console.log('Detecting face on the final high-res image...');
        // 在裁切後的影像上進行偵測，以獲得最精準的相對位置
        const finalDetections = await faceapi.detectAllFaces(capturedBmp, new faceapi.TinyFaceDetectorOptions());
        
        if (finalDetections.length > 0) {
          const face = finalDetections[0].box;
          // 此處的 face.x, face.y 等座標是相對於 capturedBmp (高解析度照片) 的
          drawLogoOnCanvas(ctx, logoImage, face, { sx, sy, sWidth });
        } else {
          console.warn('No face detected on the final image, logo will not be added.');
        }
      }

      previewImage.src = canvas.toDataURL('image/jpeg', 0.9);
      cameraContainer.style.display = 'none';
      previewContainer.style.display = 'flex';
    }

    function calculateCoverCrop(srcWidth, srcHeight, containerWidth, containerHeight) {
      const srcAspect = srcWidth / srcHeight;
      const containerAspect = containerWidth / containerHeight;
      let sx = 0, sy = 0, sWidth = srcWidth, sHeight = srcHeight;
      if (containerAspect < srcAspect) {
        sWidth = srcHeight * containerAspect;
        sx = (srcWidth - sWidth) / 2;
      } else if (containerAspect > srcAspect) {
        sHeight = srcWidth / containerAspect;
        sy = (srcHeight - sHeight) / 2;
      }
      return { sx, sy, sWidth, sHeight };
    }

    function drawFlippedAndCroppedImage(context, image, sx, sy, sWidth, sHeight) {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      if (currentFacingMode === 'user') {
        context.save();
        context.scale(-1, 1);
        context.translate(-context.canvas.width, 0);
      }
      context.drawImage(image, sx, sy, sWidth, sHeight, 0, 0, context.canvas.width, context.canvas.height);
      if (currentFacingMode === 'user') {
        context.restore();
      }
    }
    
    // ===== 核心修改：drawLogoOnCanvas 現在接收原始人臉偵測框 =====
    function drawLogoOnCanvas(context, logo, faceBox, cropInfo) {
      const { sx, sy, sWidth } = cropInfo;
      const drawScale = context.canvas.width / sWidth;

      // 計算 Logo 在原始高解析度照片中的位置
      const logoWidthOrig = faceBox.width * 0.5;
      const logoHeightOrig = logo.naturalHeight * (logoWidthOrig / logo.naturalWidth);
      const logoXOrig = faceBox.x + (faceBox.width / 2) - (logoWidthOrig / 2) - 80;
      const logoYOrig = faceBox.y - logoHeightOrig - 30;

      // 將原始照片中的 Logo 座標，轉換到最終裁切後的 Canvas 座標系統
      const logoDrawX = (logoXOrig - sx) * drawScale;
      const logoDrawY = (logoYOrig - sy) * drawScale;
      const logoDrawWidth = logoWidthOrig * drawScale;
      const logoDrawHeight = logoHeightOrig * drawScale;
      
      if (currentFacingMode === 'user') {
        const finalLogoX = context.canvas.width - logoDrawX - logoDrawWidth;
        context.drawImage(logo, finalLogoX, logoDrawY, logoDrawWidth, logoDrawHeight);
      } else {
        context.drawImage(logo, logoDrawX, logoDrawY, logoDrawWidth, logoDrawHeight);
      }
    }

    function applyBeautifyFilter(context) {
        const { width, height } = context.canvas;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        tempCtx.drawImage(context.canvas, 0, 0);
        context.filter = 'brightness(1.05) contrast(1.05) saturate(1.1)';
        context.drawImage(tempCanvas, 0, 0);
        context.filter = 'none';
    }

    function savePicture() {
      const imageDataURL = previewImage.src;
      const downloadLink = document.createElement('a');
      downloadLink.href = imageDataURL;
      downloadLink.download = `selfie-${Date.now()}.jpg`;
      downloadLink.click();
    }

    function retakePicture() {
      previewContainer.style.display = 'none';
      cameraContainer.style.display = 'flex';
      if (faceModelsLoaded) {
        startPreviewFaceDetection();
      }
    }

    function switchCamera() {
      stopPreviewFaceDetection();
      currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
      startCamera(currentFacingMode);
    }

    captureButton.addEventListener('click', takePicture);
    saveButton.addEventListener('click', savePicture);
    retakeButton.addEventListener('click', retakePicture);
    switchCameraButton.addEventListener('click', switchCamera);
    addLogoCheckbox.addEventListener('change', () => {
      if (!addLogoCheckbox.checked) {
        dynamicLogo.style.display = 'none';
      }
    });

    startCamera(currentFacingMode);
  </script>
</body>
</html>
